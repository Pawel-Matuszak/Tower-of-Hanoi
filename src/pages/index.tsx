import { DndContext, DragEndEvent } from "@dnd-kit/core";
import Head from "next/head";
import { Dispatch, SetStateAction, useEffect, useState } from "react";
import StackComponent from "~/components/StackComponent";
import { Stack } from "~/types";
import { STARTING_ITEMS } from "~/utils";

export default function Home() {
  const [stackLeft, setStackLeft] = useState<Stack>(STARTING_ITEMS);
  const [stackMiddle, setStackMiddle] = useState<Stack>([]);
  const [stackRight, setStackRight] = useState<Stack>([]);
  const [count, setCount] = useState(0);
  const [isWon, setIsWon] = useState(false);

  useEffect(() => {
    if (stackRight.length === STARTING_ITEMS.length) setIsWon(true);
  }, [stackRight]);

  const move = (
    dispatchFrom: Dispatch<SetStateAction<Stack>>,
    dispatchTo: Dispatch<SetStateAction<Stack>>
  ) => {
    dispatchFrom((prev) => {
      if (prev.length === 0) return [];

      const poppedItem = prev[0] ?? 0;
      dispatchTo((prev) => [poppedItem, ...prev]);
      return prev.slice(1);
    });
  };

  const validateMove = (stackFrom: Stack, stackTo: Stack) => {
    if (stackFrom.length === 0) return false;
    const fromItem = stackFrom[0];
    const toItem = stackTo[0];
    return !isWon && (!toItem || !fromItem || fromItem < toItem);
  };

  const onDragEnd = (event: DragEndEvent) => {
    if (!event.over) return;
    const discId = event.active.id;
    const stackDestId: "left" | "middle" | "right" = event.over.id as
      | "left"
      | "middle"
      | "right";
    const stackStartId =
      stackLeft[0] == discId
        ? "left"
        : stackMiddle[0] == discId
        ? "middle"
        : stackRight[0] == discId
        ? "right"
        : null;

    if (stackStartId === null) return;

    const stackMap = {
      left: stackLeft,
      middle: stackMiddle,
      right: stackRight,
    };

    const stackDispatchMap = {
      left: setStackLeft,
      middle: setStackMiddle,
      right: setStackRight,
    };

    if (validateMove(stackMap[stackStartId], stackMap[stackDestId])) {
      move(stackDispatchMap[stackStartId], stackDispatchMap[stackDestId]);
      setCount((prev) => prev + 1);
    }
  };

  return (
    <>
      <Head>
        <title>Tower of Hanoi</title>
        <meta name="description" content="Generated by create-t3-app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <main className="flex min-h-screen flex-col items-center justify-center bg-gradient-to-b from-[#1C244A] to-[#0e1225] text-white">
        <h1 className="my-2 text-center text-4xl font-bold">Tower of Hanoi</h1>

        <h2 className=" text-center text-xl font-bold">
          {isWon ? `You win in ${count} moves` : `Moves: ${count}`}
        </h2>
        {!isWon && (
          <h3 className="text-l my-2  text-center font-bold">
            Best: {Math.pow(2, STARTING_ITEMS.length) - 1}
          </h3>
        )}

        {/* TODO: TOOLS TO CHANGE NUMBER OF DISCS restart and auto solve */}
        <div className="mb-8 flex flex-row items-center justify-center">
          <button
            className="ml-2"
            onClick={() => {
              setStackLeft(STARTING_ITEMS);
              setStackMiddle([]);
              setStackRight([]);
              setCount(0);
              setIsWon(false);
            }}
          >
            Restart
          </button>
        </div>

        <DndContext onDragEnd={onDragEnd}>
          <div className="flex min-h-[60vh] w-screen max-w-5xl flex-row items-end justify-between">
            <StackComponent stack={stackLeft} id="left" />
            <StackComponent stack={stackMiddle} id="middle" />
            <StackComponent stack={stackRight} id="right" />
          </div>
          <div className="z-10 h-5 w-full bg-sky-800"></div>
        </DndContext>
        <p className="my-8 max-w-2xl text-center text-slate-300">
          Tower of Hanoi is a mathematical puzzle game where the objective is to
          move a stack of disks from one peg to another, using a third peg as an
          intermediary, while following the rule of placing larger disks on top
          of smaller ones. The challenge lies in completing the task with the
          fewest moves possible.
        </p>
      </main>
    </>
  );
}
