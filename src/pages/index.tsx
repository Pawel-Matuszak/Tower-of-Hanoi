import { DndContext, DragEndEvent } from "@dnd-kit/core";
import Head from "next/head";
import { Dispatch, SetStateAction, useEffect, useState } from "react";
import AutoSolver from "~/components/AutoSolver";
import DiscSlider from "~/components/DiscSlider";
import RestartBtn from "~/components/RestartBtn";
import StackComponent from "~/components/StackComponent";
import { Stack, StackName } from "~/types";
import { STARTING_ITEMS, delay } from "~/utils";

export default function Home() {
  const [discStore, setDiscStore] = useState<Stack>(STARTING_ITEMS);
  const [stackLeft, setStackLeft] = useState<Stack>(STARTING_ITEMS);
  const [stackMiddle, setStackMiddle] = useState<Stack>([]);
  const [stackRight, setStackRight] = useState<Stack>([]);
  const [count, setCount] = useState(0);
  const [bestPossibleCount, setBestPossibleCount] = useState(0);
  const [moveDisabled, setMoveDisabled] = useState(true);

  useEffect(() => {
    newGameInit(STARTING_ITEMS);
  }, []);

  useEffect(() => {
    //game won
    if (stackRight.length === discStore.length) setMoveDisabled(true);
  }, [stackRight, discStore]);

  const move = async (
    dispatchFrom: Dispatch<SetStateAction<Stack>>,
    dispatchTo: Dispatch<SetStateAction<Stack>>
  ) => {
    await new Promise((res) => {
      dispatchFrom((prev) => {
        if (prev.length === 0) return [];

        const poppedItem = prev[0] ?? 0;
        dispatchTo((prev) => [poppedItem, ...prev]);
        setCount((prev) => prev + 1);

        res(true);
        return prev.slice(1);
      });
    });
  };

  const validateMove = (stackFrom: Stack, stackTo: Stack) => {
    if (stackFrom.length === 0) return false;
    const fromItem = stackFrom[0];
    const toItem = stackTo[0];
    return !moveDisabled && (!toItem || !fromItem || fromItem < toItem);
  };

  const stackMap = {
    left: stackLeft,
    middle: stackMiddle,
    right: stackRight,
  };

  const stackDispatchMap = {
    left: setStackLeft,
    middle: setStackMiddle,
    right: setStackRight,
  };

  const onDragEnd = async (event: DragEndEvent) => {
    if (!event.over) return;
    const discId = event.active.id;
    const stackDestId: "left" | "middle" | "right" = event.over.id as StackName;
    const stackStartId =
      stackLeft[0] == discId
        ? "left"
        : stackMiddle[0] == discId
        ? "middle"
        : stackRight[0] == discId
        ? "right"
        : null;

    if (stackStartId === null || moveDisabled) return;

    if (validateMove(stackMap[stackStartId], stackMap[stackDestId])) {
      await move(stackDispatchMap[stackStartId], stackDispatchMap[stackDestId]);
    }
  };

  const autoSolve = async () => {
    setMoveDisabled(true);
    newGameInit(discStore);
    await solveTower(discStore.length, "left", "right", "middle");
    setMoveDisabled(false);
  };

  const solveTower = async (
    n: number,
    from: StackName,
    to: StackName,
    aux: StackName
  ) => {
    if (n === 0) {
      return;
    }
    await solveTower(n - 1, from, aux, to);
    console.log(`Move disk ${n} from ${from} to ${to}`);
    await delay(500);
    await move(stackDispatchMap[from], stackDispatchMap[to]);
    await solveTower(n - 1, aux, to, from);
  };

  const newGameInit = (discArray: number[]) => {
    setDiscStore(discArray);
    setStackLeft(discArray);
    setStackMiddle([]);
    setStackRight([]);
    setCount(0);
    setMoveDisabled(false);
    setBestPossibleCount(Math.pow(2, discArray.length) - 1);
  };

  const getDiscNumber = (discNumber: number) => {
    const newStack = Array.from({ length: discNumber }, (_, i) => i + 1);
    newGameInit(newStack);
    setDiscStore(newStack);
  };

  return (
    <>
      <Head>
        <title>Tower of Hanoi</title>
        <meta name="description" content="Generated by create-t3-app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <main className="flex min-h-screen flex-col items-center justify-center bg-gradient-to-b from-[#1C244A] to-[#0e1225] text-white">
        <h1 className="my-2 text-center text-4xl font-bold">Tower of Hanoi</h1>
        <h2 className=" text-center text-xl font-bold">
          {moveDisabled ? `You win in ${count} moves` : `Moves: ${count}`}
        </h2>

        <h3 className="text-l my-2  text-center font-bold">
          Best: {bestPossibleCount}
        </h3>

        <div className="mt-8 flex flex-row flex-wrap items-center justify-center">
          <DiscSlider getDiscNumber={getDiscNumber} />
          <RestartBtn onRestart={newGameInit} discStore={discStore} />
          <AutoSolver autoSolve={autoSolve} discStore={discStore} />
        </div>

        <DndContext onDragEnd={onDragEnd}>
          <div
            className={`flex min-h-[50vh] w-screen ${
              discStore.length < 7 ? "max-w-5xl" : "max-w-6xl"
            } flex-row items-end justify-between`}
          >
            <StackComponent stack={stackLeft} id="left" discStore={discStore} />
            <StackComponent
              stack={stackMiddle}
              id="middle"
              discStore={discStore}
            />
            <StackComponent
              stack={stackRight}
              id="right"
              discStore={discStore}
            />
          </div>
          <div className="z-10 h-5 w-full bg-sky-700"></div>
        </DndContext>
        <p className="my-8 max-w-2xl px-2 text-center text-slate-300">
          Tower of Hanoi is a mathematical puzzle game where the objective is to
          move a stack of disks from one peg to another, using a third peg as an
          intermediary, while following the rule of placing larger disks on top
          of smaller ones. The challenge lies in completing the task with the
          fewest moves possible.
        </p>
      </main>
    </>
  );
}
